const Database = require("better-sqlite3")
const Artist = require("../dataClasses/Artist")
const ArtistThumbnail = require("../dataClasses/ArtistThumbnail")
const Song = require("../dataClasses/song")
const SongViews = require("../dataClasses/SongViews")
const ArtistThumbnailType = require("../enums/ArtistThumbnailType")
const ArtistType = require("../enums/ArtistType")
const SongType = require("../enums/SongType")

module.exports = class SongsDataProxy {

    /**
     * Creates a new SongsDataProxy
     * 
     * @param {Database.Database} db The db for this proxy to use.
     */
    constructor(db) {
        this.db = db
    }

    // private functions

    /**
     * Builds an Artist object and returns it using data provided from the database.
     * 
     * @param {Object} artistData 
     * @param {Object[]} artistNames 
     * @param {Object[]} artistThumbnails 
     * @returns {Artist} The built Artist object.
     */
    #buildArtist(
        artistData,
        artistNames,
        artistThumbnails
    ) {
        // process names
        const names = []
        for (const [_, nameData] of artistNames.entries()) {
            names[nameData.name_type] = nameData.name
        }

        // process thumbnails
        const thumbnails = []
        for (const [_, thumbnailData] of artistThumbnails.entries()) {
            const thumbType = thumbnailData.thumbnail_type
            thumbnails[thumbType] = new ArtistThumbnail(
                ArtistThumbnailType.fromId(thumbType),
                thumbnailData.url,
                thumbnailData.average_color
            )
        }

        return new Artist(
            artistData.id,
            ArtistType.fromId(artistData.artist_type),
            artistData.publish_date,
            artistData.addition_date,
            names,
            thumbnails
        )
    }

    /**
     * Builds an Song object and returns it using data provided from the database.
     * 
     * @param {Object} songData 
     * @param {Object[]} songNames 
     * @param {Artist[]} songArtists
     * @param {SongViews=} songViews
     * @returns {Song} The built Song object.
     */
    #buildSong(
        songData,
        songNames,
        songArtists,
        songViews
    ) {
        // process names
        const names = []
        for (const [_, nameData] of songNames.entries()) {
            names[nameData.name_type] = nameData.name
        }

        return new Song(
            songData.id,
            songData.publish_date,
            songData.addition_date,
            SongType.fromId(songData.song_type),
            songData.thumbnail,
            songData.maxres_thumbnail,
            songData.average_color,
            songData.fandom_url,
            songArtists,
            names,
            songViews
        )
    }

    /**
     * Synchronously gets the artist associated with the provided artist id.
     * Returns null if the artist does not exist.
     * 
     * @param {number} artistId The ID of the artist to get.
     * @returns {Artist|null} The artist associated with artistId
     */
    #getArtistSync(
        artistId
    ) {
        const db = this.db

        const artistData = db.prepare(`
        SELECT id, artist_type, publish_date, addition_date
        FROM artists
        WHERE id = ?`).get(artistId)

        // return null if the artist doesn't exist.
        if (artistData == undefined) { return null }

        const artistNames = db.prepare(`
        SELECT name, name_type
        FROM artists_names
        WHERE artist_id = ?`).all(artistId)

        const artistThumbnails = db.prepare(`
        SELECT thumbnail_type, url, average_color
        FROM artists_thumbnails
        WHERE artist_id = ?`).all(artistId)

        return this.#buildArtist(
            artistData,
            artistNames,
            artistThumbnails
        )
    }

    /**
     * Synchronously gets the song associated with the provided song id.
     * Returns null if the song does not exist.
     * 
     * @param {number} songId The ID of the song to get.
     * @returns {Song|null} The song associated with songId
     */
    #getSongSync(
        songId
    ) {
        const db = this.db

        const songData = db.prepare(`
        SELECT id, publish_date, addition_date, song_type, thumbnail, maxres_thumbnail, average_color, fandom_url
        FROM songs
        WHERE id = ?`).get(songId)
                
        // resolve with null if the song was not found
        if (songData == undefined) { return null }

        // get names
        const songNames = db.prepare(`
        SELECT name, name_type 
        FROM songs_names
        WHERE song_id = ?`).all(songId)

        // get song artists
        const songArtists = db.prepare(`
        SELECT artist_id
        FROM songs_artists
        WHERE song_id = ?`).all(songId)

        // get artists data
        const artists = []
        for (const [_, songArtist] of songArtists.entries()) {
            artists.push(this.#getArtistSync(songArtist.artist_id))
        }

        return this.#buildSong(
            songData,
            songNames,
            artists
        )
    }

    /**
     * Checks if a song exists within the database.
     * 
     * @param {number} id The ID of the song to check the existence of.
     * @returns {Promise<Boolean>} A promise that resolves upon the completion of this function.
     */
    songExists(id) {
        return new Promise((resolve, reject) => {
            try {
                resolve(this.db.prepare('SELECT id FROM songs WHERE id = ? LIMIT 1').get(id) ? true : false)
            } catch (error) {
                reject(error)
            }
        })
    }

    /**
     * Checks if a artist exists within the database.
     * 
     * @param {number} id The ID of the artist to check the existence of.
     * @returns {Promise<Boolean>} A promise that resolves upon the completion of this function.
     */
    artistExists(id) {
        return new Promise((resolve, reject) => {
            try {
                resolve(this.db.prepare('SELECT id FROM artists WHERE id = ? LIMIT 1').get(id) ? true : false)
            } catch (error) {
                reject(error)
            }
        }) 
    }

    /**
     * Asynchronously gets a song from the database.
     * Returns null if no song was found.
     * 
     * @param {number} id The id of the song to get.
     * @returns {Promise<Song|null>} A promise that resolves with a Song or null.
     */
    getSong(id) {
        return new Promise((resolve, reject) => {
            try {
                resolve(this.#getSongSync(id))
            } catch (error) {
                reject(error)
            }
        })
    }
    
    /**
     * Asynchronously gets an artist from the database.
     * Returns nulls if no artist was found.
     * 
     * @param id The id of the artist to get.
     * @returns {Promise<Artist|null>} A promise that resolves with an Artist or null.
     */
    getArtist(id) {
        return new Promise((resolve, reject) => {
            try {
                resolve(this.#getArtistSync(id))
            } catch (error) {
                reject(error)
            }
        })
    }

    /**
     * Inserts an artist into the database.
     * 
     * @param {Artist} artist The artist to insert.
     * @returns {Promise} A promise that resolves upon the artist being inserted.
     */
    insertArtist(artist) {
        return new Promise((resolve, reject) => {
            try {
                
                const db = this.db
                const artistId = artist.id

                // prepare statement to insert into artists
                const artistsInsertStatement = db.prepare(`
                REPLACE INTO artists (id, artist_type, publish_date, addition_date)
                VALUES (?, ?, ?, ?)`)
                // prepare statement to insert into artists names
                const artistsNamesInsertStatement = db.prepare(`
                REPLACE INTO artists_names (artist_id, name, name_type)
                VALUES (?, ?, ?)`)
                // prepare statement to insert into artists thumbnails
                const artistsThumnailsInsertStatement = db.prepare(`
                REPLACE INTO artists_thumbnails (thumbnail_type, url, artist_id, average_color)
                VALUES (?, ?, ?, ?)`)

                // insert artist into artists
                artistsInsertStatement.run(
                    artistId,
                    artist.type.id,
                    artist.publishDate,
                    artist.additionDate
                )
                // insert names
                for (const [nameType, name] of Object.entries(artist.names)) {
                    artistsNamesInsertStatement.run(
                        artistId,
                        name,
                        nameType
                    )
                }
                // insert thumbnails
                for (const [thumbnailType, thumbnail] of Object.entries(artist.thumbnails)) {
                    artistsThumnailsInsertStatement.run(
                        thumbnailType,
                        thumbnail.url,
                        artistId,
                        thumbnail.averageColor
                    )
                }
                resolve()
            } catch (error) {
                reject(error)
            }
        })
    }

    /**
     * Inserts a new song into the database
     * 
     * @param {Song} song The song to insert.
     * @returns {Promise} A promise that resolves upon the completion of this function.
     */
    insertSong(song) {
        return new Promise(async (resolve, reject) => {
            try {
                const db = this.db

                const songId = song.id

                // prepare statement to insert into songs
                const songsInsertStatement = db.prepare(`
                REPLACE INTO songs (id, publish_date, addition_date, song_type, thumbnail, maxres_thumbnail, average_color, fandom_url)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)`)

                // prepare statement to insert into songs artists
                const songsArtistsInsertStatement = db.prepare(`
                REPLACE INTO songs_artists (song_id, artist_id)
                VALUES (?, ?)`)

                // prepare statement to insert into songs names
                const songsNamesInsertStatement = db.prepare(`
                REPLACE INTO songs_names (song_id, name, name_type)
                VALUES (?, ?, ?)`)

                // insert into songs table
                songsInsertStatement.run(
                    songId,
                    song.publishDate,
                    song.additionDate,
                    song.type.id,
                    song.thumbnail,
                    song.maxresThumbnail,
                    song.averageColor,
                    song.fandomUrl
                )

                // insert artists into song artists table
                for (const [_, artist] of song.artists.entries()) {
                    const artistId = artist.id
                    if (!(await this.artistExists(artistId))) {
                        await this.insertArtist(artist)
                    }
                    songsArtistsInsertStatement.run(
                        songId,
                        artistId,
                    )
                }

                // insert names into songs names table
                for (const [nameType, name] of Object.entries(song.names)) {
                    songsNamesInsertStatement.run(
                        songId,
                        name,
                        nameType
                    )
                }

                resolve()
            } catch (error) {
                reject(error)
            }
        })
    }
}